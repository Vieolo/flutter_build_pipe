import 'dart:io';

import 'package:build_pipe/utils/console.utils.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart' as yaml;

/// The platforms the application will be built for
enum TargetPlatform { web, ios, android, macos, windows, linux }

enum WebVersioningType {
  semver,
  hash;

  static WebVersioningType getByName(String? n) {
    return WebVersioningType.values.firstWhere(
      (z) => z.name == n,
      orElse: () => WebVersioningType.hash,
    );
  }

  bool get isHash => this == WebVersioningType.hash;
}

class IOSPublishConfig {
  // 1. path to build file `e.g. build/ios/ipa/yourapp.ipa`
  String outputFilePath;
  // 2. App's Apple ID `App Store Connect > Your App > App Information > Apple ID`
  String appAppleID;
  // 3. Bundle id `com.example.app`
  String bundleID;
  // 4. API key `123XX1234X`
  String keyID;
  // 5. API issuer ID `App Store Connect > Integrations > App Store Connect API > Issuer ID`
  String issuerID;

  IOSPublishConfig({required this.keyID, required this.appAppleID, required this.bundleID, required this.issuerID, required this.outputFilePath});

  factory IOSPublishConfig.fromMap(yaml.YamlMap data) {
    return IOSPublishConfig(
      appAppleID: Platform.environment[data["appAppleID"]]!,
      keyID: Platform.environment[data["keyID"]]!,
      issuerID: Platform.environment[data["issuerID"]]!,
      bundleID: data["bundleID"],
      outputFilePath: data["outputFilePath"],
    );
  }

  static (bool, String?) isValid(yaml.YamlMap data) {
    if (!data.containsKey("keyID") || data["keyID"] == "" || !Platform.environment.containsKey(data["keyID"]) || Platform.environment["keyID"] == "") {
      return (
        false,
        "'keyID' env variable is missing from the publish config for iOS or invalid. You can get the key ID by creating an API key from 'App Store Connect' > 'Users & Access' > 'Integrations'.",
      );
    }

    if (!data.containsKey("issuerID") || data["issuerID"] == "" || !Platform.environment.containsKey(data["issuerID"]) || Platform.environment["issuerID"] == "") {
      return (false, "'issuerID' env variable is missing from the publish config for iOS or invalid. You can get the issuer ID by visiting 'App Store Connect' > 'Users & Access' > 'Integrations'.");
    }

    if (!data.containsKey("appAppleID") || data["appAppleID"] == "" || !Platform.environment.containsKey(data["appAppleID"]) || Platform.environment["appAppleID"] == "") {
      return (
        false,
        "'appAppleID' env variable is missing from the publish config for iOS or invalid. You can get the apple ID of your app from the 'App Information' section of your app in App Store Connect.",
      );
    }

    if (!data.containsKey("bundleID") || data["bundleID"] == "") {
      return (false, "'bundleID' is missing from the publish config for iOS. The bundle id is structured as 'com.example.your_app'.");
    }

    if (!data.containsKey("outputFilePath") || data["outputFilePath"] == "") {
      return (false, "'outputFilePath' is missing from the publish config for iOS. This is the path to the build file generated by the 'flutter build' command. e.g. build/ios/ipa/yourapp.ipa");
    }

    return (true, null);
  }
}

/// The class responsible for hold and parsing the user provided config
class BuildConfigPlatform {
  // General
  TargetPlatform platform;
  String buildCommand;

  // Web specific
  bool? addVersionQueryParam;
  WebVersioningType? webVersioningType;

  // iOS specific
  IOSPublishConfig? iosPublishConfig;

  BuildConfigPlatform({
    required this.platform,
    required this.buildCommand,
    this.addVersionQueryParam,
    this.webVersioningType,
    this.iosPublishConfig,
  });

  /// Parses a map to `BuildConfigPlatform`
  static BuildConfigPlatform? fromMap(yaml.YamlMap data, TargetPlatform platform) {
    if (!data.containsKey("build_command") || data["build_command"].toString().isEmpty) {
      return null;
    }

    var bcp = BuildConfigPlatform(
      platform: platform,
      buildCommand: data["build_command"],
    );

    if (platform == TargetPlatform.web) {
      bcp.addVersionQueryParam = (data['add_version_query_param'] ?? true);
      bcp.webVersioningType = WebVersioningType.getByName(data['query_param_versioning_type']);
    }

    if (platform == TargetPlatform.ios) {
      if (data.containsKey("publish")) {
        var iosPublishValidation = IOSPublishConfig.isValid(data["publish"]);
        if (!iosPublishValidation.$1) {
          Console.logError("Invalid publish config for iOS -> ${iosPublishValidation.$2 ?? "-"}");
          exit(1);
        }
        bcp.iosPublishConfig = IOSPublishConfig.fromMap(data["publish"]);
      }
    }

    return bcp;
  }
}

/// The actual class holding the fields of the config
class BuildConfig {
  BuildConfigPlatform? web;
  BuildConfigPlatform? ios;
  BuildConfigPlatform? android;
  BuildConfigPlatform? macos;
  BuildConfigPlatform? windows;
  BuildConfigPlatform? linux;
  String? xcodeDerivedKey;
  bool cleanFlutter;
  bool printstdout;
  DateTime timestamp;
  String version;
  String buildVersion;
  bool generateLog;
  String? postBuildCommand;

  BuildConfig({
    this.android,
    this.ios,
    this.linux,
    this.macos,
    this.web,
    this.windows,
    this.xcodeDerivedKey,
    this.postBuildCommand,
    required this.cleanFlutter,
    required this.printstdout,
    required this.timestamp,
    required this.version,
    required this.generateLog,
    required this.buildVersion,
  });

  /// Parsed the config from the map
  factory BuildConfig.fromMap(yaml.YamlMap data, String version, String buildVersion) {
    yaml.YamlMap platforms = data["platforms"] ?? {};
    return BuildConfig(
      android: platforms.containsKey("android")
          ? BuildConfigPlatform.fromMap(
              platforms["android"],
              TargetPlatform.android,
            )
          : null,
      ios: platforms.containsKey("ios") ? BuildConfigPlatform.fromMap(platforms["ios"], TargetPlatform.ios) : null,
      macos: platforms.containsKey("macos")
          ? BuildConfigPlatform.fromMap(
              platforms["macos"],
              TargetPlatform.macos,
            )
          : null,
      linux: platforms.containsKey("linux")
          ? BuildConfigPlatform.fromMap(
              platforms["linux"],
              TargetPlatform.linux,
            )
          : null,
      windows: platforms.containsKey("windows")
          ? BuildConfigPlatform.fromMap(
              platforms["windows"],
              TargetPlatform.windows,
            )
          : null,
      web: platforms.containsKey("web") ? BuildConfigPlatform.fromMap(platforms["web"], TargetPlatform.web) : null,
      xcodeDerivedKey: data["xcode_derived_data_path_env_key"],
      cleanFlutter: data["clean_flutter"] ?? true,
      generateLog: data["generate_log"] ?? true,
      printstdout: data["print_stdout"] ?? false,
      postBuildCommand: data["post_build_command"],
      timestamp: DateTime.now(),
      version: version,
      buildVersion: buildVersion,
    );
  }

  /// Gets the path of the log file, if log generation is not prevented via the config
  String get logFile {
    String fileName = "${timestamp.toIso8601String()}.log";

    // In windows, it seems that, the file name cannot
    // contain `:`
    if (Platform.isWindows) {
      fileName = fileName.replaceAll(":", "_");
    }

    return generateLog
        ? p.join(
            Directory.current.path,
            ".flutter_build_pipe",
            "logs",
            version,
            fileName,
          )
        : "";
  }

  /// Checks if the XCode derived data is provided AND there is a build target for Apple devices
  bool get needXCodeDerivedCleaning => (ios != null || macos != null) && xcodeDerivedKey != null && xcodeDerivedKey!.isNotEmpty;

  /// The list of target platforms provided in the config
  List<TargetPlatform> get platforms => [
    if (ios != null) TargetPlatform.ios,
    if (android != null) TargetPlatform.android,
    if (macos != null) TargetPlatform.macos,
    if (linux != null) TargetPlatform.linux,
    if (windows != null) TargetPlatform.windows,
    if (web != null) TargetPlatform.web,
  ];

  static Future<BuildConfig> readPubspec() async {
    final rawPubspecFile = File('pubspec.yaml');
    if (!(await rawPubspecFile.exists())) {
      Console.logError("pubspec.yaml file could not be found!");
      exit(1);
    }

    final pubspec = yaml.loadYaml(await rawPubspecFile.readAsString());
    if (!(pubspec as yaml.YamlMap).containsKey("build_pipe")) {
      Console.logError(
        "please add the build_pipe configuration to your pubspec file!",
      );
      exit(1);
    }

    final config = BuildConfig.fromMap(
      pubspec["build_pipe"],
      pubspec["version"].split("+")[0],
      pubspec["version"].split("+")[1],
    );

    if (config.platforms.isEmpty) {
      Console.logError(
        "No target platforms were detected. Please add your target platforms to pubspec",
      );
      exit(1);
    }

    return config;
  }
}
