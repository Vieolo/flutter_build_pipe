import 'dart:io';

import 'package:build_pipe/utils/console.utils.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart' as yaml;

/// The platforms the application will be built for
enum TargetPlatform { web, ios, android, macos, windows, linux }

enum WebVersioningType {
  semver,
  hash;

  static WebVersioningType getByName(String? n) {
    return WebVersioningType.values.firstWhere(
      (z) => z.name == n,
      orElse: () => WebVersioningType.hash,
    );
  }

  bool get isHash => this == WebVersioningType.hash;
}

class ApplePublishConfig {
  // 1. path to build file `e.g. build/ios/ipa/yourapp.ipa`
  String outputFilePath;
  // 2. App's Apple ID `App Store Connect > Your App > App Information > Apple ID`
  String appAppleID;
  // 3. Bundle id `com.example.app`
  String bundleID;
  // 4. API key `123XX1234X`
  String keyID;
  // 5. API issuer ID `App Store Connect > Integrations > App Store Connect API > Issuer ID`
  String issuerID;

  ApplePublishConfig({required this.keyID, required this.appAppleID, required this.bundleID, required this.issuerID, required this.outputFilePath});

  factory ApplePublishConfig.fromMap(yaml.YamlMap data) {
    return ApplePublishConfig(
      appAppleID: Platform.environment[data["appAppleID"]]!,
      keyID: Platform.environment[data["keyID"]]!,
      issuerID: Platform.environment[data["issuerID"]]!,
      bundleID: data["bundleID"],
      outputFilePath: data["outputFilePath"],
    );
  }

  static (bool, String?) isValid(yaml.YamlMap data, TargetPlatform tp) {
    if (!data.containsKey("keyID") || data["keyID"] == "" || !Platform.environment.containsKey(data["keyID"]) || Platform.environment["keyID"] == "") {
      return (
        false,
        "'keyID' env variable is missing from the publish config for ${tp.name} or invalid. You can get the key ID by creating an API key from 'App Store Connect' > 'Users & Access' > 'Integrations'.",
      );
    }

    if (!data.containsKey("issuerID") || data["issuerID"] == "" || !Platform.environment.containsKey(data["issuerID"]) || Platform.environment["issuerID"] == "") {
      return (
        false,
        "'issuerID' env variable is missing from the publish config for ${tp.name} or invalid. You can get the issuer ID by visiting 'App Store Connect' > 'Users & Access' > 'Integrations'.",
      );
    }

    if (!data.containsKey("appAppleID") || data["appAppleID"] == "" || !Platform.environment.containsKey(data["appAppleID"]) || Platform.environment["appAppleID"] == "") {
      return (
        false,
        "'appAppleID' env variable is missing from the publish config for ${tp.name} or invalid. You can get the apple ID of your app from the 'App Information' section of your app in App Store Connect.",
      );
    }

    if (!data.containsKey("bundleID") || data["bundleID"] == "") {
      return (false, "'bundleID' is missing from the publish config for ${tp.name}. The bundle id is structured as 'com.example.your_app'.");
    }

    if (!data.containsKey("outputFilePath") || data["outputFilePath"] == "") {
      String examplePath = "build/ios/ipa/yourapp.ipa";
      if (tp == TargetPlatform.macos) {
        examplePath = "build/macos/Build/Products/Release/yourapp.app";
      }
      return (
        false,
        "'outputFilePath' is missing from the publish config for ${tp.name}. This is the path to the build ${tp == TargetPlatform.macos ? "folder" : "file"} generated by the 'flutter build' command. e.g. $examplePath",
      );
    }

    return (true, null);
  }
}

/// The class responsible for hold and parsing the user provided config
class BuildConfigPlatform {
  // General
  TargetPlatform platform;
  String buildCommand;

  // Web specific
  bool? addVersionQueryParam;
  WebVersioningType? webVersioningType;

  // iOS specific
  ApplePublishConfig? iosPublishConfig;

  // macOS specific
  ApplePublishConfig? macosPublishConfig;

  BuildConfigPlatform({
    required this.platform,
    required this.buildCommand,
    this.addVersionQueryParam,
    this.webVersioningType,
    this.iosPublishConfig,
    this.macosPublishConfig,
  });

  /// Parses a map to `BuildConfigPlatform`
  static BuildConfigPlatform? fromMap(yaml.YamlMap data, TargetPlatform platform) {
    if (!data.containsKey("build_command") || data["build_command"].toString().isEmpty) {
      return null;
    }

    var bcp = BuildConfigPlatform(
      platform: platform,
      buildCommand: data["build_command"],
    );

    if (platform == TargetPlatform.web) {
      bcp.addVersionQueryParam = (data['add_version_query_param'] ?? true);
      bcp.webVersioningType = WebVersioningType.getByName(data['query_param_versioning_type']);
    }

    if (platform == TargetPlatform.ios) {
      if (data.containsKey("publish")) {
        var iosPublishValidation = ApplePublishConfig.isValid(data["publish"], TargetPlatform.ios);
        if (!iosPublishValidation.$1) {
          Console.logError("Invalid publish config for iOS -> ${iosPublishValidation.$2 ?? "-"}");
          exit(1);
        }
        bcp.iosPublishConfig = ApplePublishConfig.fromMap(data["publish"]);
      }
    }

    if (platform == TargetPlatform.macos) {
      if (data.containsKey("publish")) {
        var macosPublishValidation = ApplePublishConfig.isValid(data["publish"], TargetPlatform.macos);
        if (!macosPublishValidation.$1) {
          Console.logError("Invalid publish config for macOS -> ${macosPublishValidation.$2 ?? "-"}");
          exit(1);
        }
        bcp.macosPublishConfig = ApplePublishConfig.fromMap(data["publish"]);
      }
    }

    return bcp;
  }
}

/// The actual class holding the fields of the config
class BuildConfig {
  BuildConfigPlatform? web;
  BuildConfigPlatform? ios;
  BuildConfigPlatform? android;
  BuildConfigPlatform? macos;
  BuildConfigPlatform? windows;
  BuildConfigPlatform? linux;
  String? xcodeDerivedKey;
  bool cleanFlutter;
  bool printstdout;
  DateTime timestamp;
  String version;
  String buildVersion;
  bool generateLog;
  String? postBuildCommand;

  BuildConfig({
    this.android,
    this.ios,
    this.linux,
    this.macos,
    this.web,
    this.windows,
    this.xcodeDerivedKey,
    this.postBuildCommand,
    required this.cleanFlutter,
    required this.printstdout,
    required this.timestamp,
    required this.version,
    required this.generateLog,
    required this.buildVersion,
  });

  /// Parsed the config from the map
  factory BuildConfig.fromMap(yaml.YamlMap data, String version, String buildVersion) {
    yaml.YamlMap platforms = data["platforms"] ?? {};
    return BuildConfig(
      android: platforms.containsKey("android")
          ? BuildConfigPlatform.fromMap(
              platforms["android"],
              TargetPlatform.android,
            )
          : null,
      ios: platforms.containsKey("ios") ? BuildConfigPlatform.fromMap(platforms["ios"], TargetPlatform.ios) : null,
      macos: platforms.containsKey("macos")
          ? BuildConfigPlatform.fromMap(
              platforms["macos"],
              TargetPlatform.macos,
            )
          : null,
      linux: platforms.containsKey("linux")
          ? BuildConfigPlatform.fromMap(
              platforms["linux"],
              TargetPlatform.linux,
            )
          : null,
      windows: platforms.containsKey("windows")
          ? BuildConfigPlatform.fromMap(
              platforms["windows"],
              TargetPlatform.windows,
            )
          : null,
      web: platforms.containsKey("web") ? BuildConfigPlatform.fromMap(platforms["web"], TargetPlatform.web) : null,
      xcodeDerivedKey: data["xcode_derived_data_path_env_key"],
      cleanFlutter: data["clean_flutter"] ?? true,
      generateLog: data["generate_log"] ?? true,
      printstdout: data["print_stdout"] ?? false,
      postBuildCommand: data["post_build_command"],
      timestamp: DateTime.now(),
      version: version,
      buildVersion: buildVersion,
    );
  }

  /// Gets the path of the log file, if log generation is not prevented via the config
  String get logFile {
    String fileName = "${timestamp.toIso8601String()}.log";

    // In windows, it seems that, the file name cannot
    // contain `:`
    if (Platform.isWindows) {
      fileName = fileName.replaceAll(":", "_");
    }

    return generateLog
        ? p.join(
            Directory.current.path,
            ".flutter_build_pipe",
            "logs",
            version,
            fileName,
          )
        : "";
  }

  /// Checks if the XCode derived data is provided AND there is a build target for Apple devices
  bool get needXCodeDerivedCleaning => (ios != null || macos != null) && xcodeDerivedKey != null && xcodeDerivedKey!.isNotEmpty;

  /// The list of target platforms provided in the config
  List<TargetPlatform> get platforms => [
    if (ios != null) TargetPlatform.ios,
    if (android != null) TargetPlatform.android,
    if (macos != null) TargetPlatform.macos,
    if (linux != null) TargetPlatform.linux,
    if (windows != null) TargetPlatform.windows,
    if (web != null) TargetPlatform.web,
  ];

  static Future<BuildConfig> readPubspec() async {
    final rawPubspecFile = File('pubspec.yaml');
    if (!(await rawPubspecFile.exists())) {
      Console.logError("pubspec.yaml file could not be found!");
      exit(1);
    }

    final pubspec = yaml.loadYaml(await rawPubspecFile.readAsString());
    if (!(pubspec as yaml.YamlMap).containsKey("build_pipe")) {
      Console.logError(
        "please add the build_pipe configuration to your pubspec file!",
      );
      exit(1);
    }

    final config = BuildConfig.fromMap(
      pubspec["build_pipe"],
      pubspec["version"].split("+")[0],
      pubspec["version"].split("+")[1],
    );

    if (config.platforms.isEmpty) {
      Console.logError(
        "No target platforms were detected. Please add your target platforms to pubspec",
      );
      exit(1);
    }

    return config;
  }
}
